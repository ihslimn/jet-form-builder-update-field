{"version":3,"sources":["@wordpress/element/src/create-interpolate-element.js"],"names":["indoc","offset","output","stack","tokenizer","createFrame","element","tokenStart","tokenLength","prevOffset","leadingTextStart","children","createInterpolateElement","interpolatedString","conversionMap","lastIndex","isValidConversionMap","TypeError","proceed","Fragment","isObject","values","Object","length","every","next","nextToken","tokenType","name","startOffset","stackDepth","addText","stackLeadingText","pop","push","substr","addChild","closeOuterElement","stackTop","text","frame","matches","exec","startedAt","index","match","isClosing","isSelfClosed","parent","endOffset"],"mappings":";;;;;;;AAGA;;AAHA;AACA;AACA;;AAGA;AAEA,IAAIA,KAAJ,EAAWC,MAAX,EAAmBC,MAAnB,EAA2BC,KAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,SAAS,GAAG,uBAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CACCC,OADD,EAECC,UAFD,EAGCC,WAHD,EAICC,UAJD,EAKCC,gBALD,EAME;AACD,SAAO;AACNJ,IAAAA,OADM;AAENC,IAAAA,UAFM;AAGNC,IAAAA,WAHM;AAINC,IAAAA,UAJM;AAKNC,IAAAA,gBALM;AAMNC,IAAAA,QAAQ,EAAE;AANJ,GAAP;AAQA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,wBAAwB,GAAG,CAAEC,kBAAF,EAAsBC,aAAtB,KAAyC;AACzEd,EAAAA,KAAK,GAAGa,kBAAR;AACAZ,EAAAA,MAAM,GAAG,CAAT;AACAC,EAAAA,MAAM,GAAG,EAAT;AACAC,EAAAA,KAAK,GAAG,EAAR;AACAC,EAAAA,SAAS,CAACW,SAAV,GAAsB,CAAtB;;AAEA,MAAK,CAAEC,oBAAoB,CAAEF,aAAF,CAA3B,EAA+C;AAC9C,UAAM,IAAIG,SAAJ,CACL,+FADK,CAAN;AAGA;;AAED,KAAG,CACF;AACA,GAFD,QAEUC,OAAO,CAAEJ,aAAF,CAFjB;;AAGA,SAAO,0BAAeK,eAAf,EAAyB,IAAzB,EAA+B,GAAGjB,MAAlC,CAAP;AACA,CAjBD;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","sourcesContent":["/**\n * Internal dependencies\n */\nimport { createElement, cloneElement, Fragment, isValidElement } from './react';\n\n/** @typedef {import('./react').WPElement} WPElement */\n\nlet indoc, offset, output, stack;\n\n/**\n * Matches tags in the localized string\n *\n * This is used for extracting the tag pattern groups for parsing the localized\n * string and along with the map converting it to a react element.\n *\n * There are four references extracted using this tokenizer:\n *\n * match: Full match of the tag (i.e. <strong>, </strong>, <br/>)\n * isClosing: The closing slash, it it exists.\n * name: The name portion of the tag (strong, br) (if )\n * isSelfClosed: The slash on a self closing tag, if it exists.\n *\n * @type {RegExp}\n */\nconst tokenizer = /<(\\/)?(\\w+)\\s*(\\/)?>/g;\n\n/**\n * The stack frame tracking parse progress.\n *\n * @typedef Frame\n *\n * @property {WPElement}   element            A parent element which may still have\n * @property {number}      tokenStart         Offset at which parent element first\n *                                            appears.\n * @property {number}      tokenLength        Length of string marking start of parent\n *                                            element.\n * @property {number}      [prevOffset]       Running offset at which parsing should\n *                                            continue.\n * @property {number}      [leadingTextStart] Offset at which last closing element\n *                                            finished, used for finding text between\n *                                            elements.\n * @property {WPElement[]} children           Children.\n */\n\n/**\n * Tracks recursive-descent parse state.\n *\n * This is a Stack frame holding parent elements until all children have been\n * parsed.\n *\n * @private\n * @param {WPElement} element            A parent element which may still have\n *                                       nested children not yet parsed.\n * @param {number}    tokenStart         Offset at which parent element first\n *                                       appears.\n * @param {number}    tokenLength        Length of string marking start of parent\n *                                       element.\n * @param {number}    [prevOffset]       Running offset at which parsing should\n *                                       continue.\n * @param {number}    [leadingTextStart] Offset at which last closing element\n *                                       finished, used for finding text between\n *                                       elements.\n *\n * @return {Frame} The stack frame tracking parse progress.\n */\nfunction createFrame(\n\telement,\n\ttokenStart,\n\ttokenLength,\n\tprevOffset,\n\tleadingTextStart\n) {\n\treturn {\n\t\telement,\n\t\ttokenStart,\n\t\ttokenLength,\n\t\tprevOffset,\n\t\tleadingTextStart,\n\t\tchildren: [],\n\t};\n}\n\n/**\n * This function creates an interpolated element from a passed in string with\n * specific tags matching how the string should be converted to an element via\n * the conversion map value.\n *\n * @example\n * For example, for the given string:\n *\n * \"This is a <span>string</span> with <a>a link</a> and a self-closing\n * <CustomComponentB/> tag\"\n *\n * You would have something like this as the conversionMap value:\n *\n * ```js\n * {\n *     span: <span />,\n *     a: <a href={ 'https://github.com' } />,\n *     CustomComponentB: <CustomComponent />,\n * }\n * ```\n *\n * @param {string} interpolatedString The interpolation string to be parsed.\n * @param {Object} conversionMap      The map used to convert the string to\n *                                    a react element.\n * @throws {TypeError}\n * @return {WPElement}  A wp element.\n */\nconst createInterpolateElement = ( interpolatedString, conversionMap ) => {\n\tindoc = interpolatedString;\n\toffset = 0;\n\toutput = [];\n\tstack = [];\n\ttokenizer.lastIndex = 0;\n\n\tif ( ! isValidConversionMap( conversionMap ) ) {\n\t\tthrow new TypeError(\n\t\t\t'The conversionMap provided is not valid. It must be an object with values that are WPElements'\n\t\t);\n\t}\n\n\tdo {\n\t\t// twiddle our thumbs\n\t} while ( proceed( conversionMap ) );\n\treturn createElement( Fragment, null, ...output );\n};\n\n/**\n * Validate conversion map.\n *\n * A map is considered valid if it's an object and every value in the object\n * is a WPElement\n *\n * @private\n *\n * @param {Object} conversionMap The map being validated.\n *\n * @return {boolean}  True means the map is valid.\n */\nconst isValidConversionMap = ( conversionMap ) => {\n\tconst isObject = typeof conversionMap === 'object';\n\tconst values = isObject && Object.values( conversionMap );\n\treturn (\n\t\tisObject &&\n\t\tvalues.length &&\n\t\tvalues.every( ( element ) => isValidElement( element ) )\n\t);\n};\n\n/**\n * This is the iterator over the matches in the string.\n *\n * @private\n *\n * @param {Object} conversionMap The conversion map for the string.\n *\n * @return {boolean} true for continuing to iterate, false for finished.\n */\nfunction proceed( conversionMap ) {\n\tconst next = nextToken();\n\tconst [ tokenType, name, startOffset, tokenLength ] = next;\n\tconst stackDepth = stack.length;\n\tconst leadingTextStart = startOffset > offset ? offset : null;\n\tif ( ! conversionMap[ name ] ) {\n\t\taddText();\n\t\treturn false;\n\t}\n\tswitch ( tokenType ) {\n\t\tcase 'no-more-tokens':\n\t\t\tif ( stackDepth !== 0 ) {\n\t\t\t\tconst {\n\t\t\t\t\tleadingTextStart: stackLeadingText,\n\t\t\t\t\ttokenStart,\n\t\t\t\t} = stack.pop();\n\t\t\t\toutput.push( indoc.substr( stackLeadingText, tokenStart ) );\n\t\t\t}\n\t\t\taddText();\n\t\t\treturn false;\n\n\t\tcase 'self-closed':\n\t\t\tif ( 0 === stackDepth ) {\n\t\t\t\tif ( null !== leadingTextStart ) {\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tindoc.substr(\n\t\t\t\t\t\t\tleadingTextStart,\n\t\t\t\t\t\t\tstartOffset - leadingTextStart\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\toutput.push( conversionMap[ name ] );\n\t\t\t\toffset = startOffset + tokenLength;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// otherwise we found an inner element\n\t\t\taddChild(\n\t\t\t\tcreateFrame( conversionMap[ name ], startOffset, tokenLength )\n\t\t\t);\n\t\t\toffset = startOffset + tokenLength;\n\t\t\treturn true;\n\n\t\tcase 'opener':\n\t\t\tstack.push(\n\t\t\t\tcreateFrame(\n\t\t\t\t\tconversionMap[ name ],\n\t\t\t\t\tstartOffset,\n\t\t\t\t\ttokenLength,\n\t\t\t\t\tstartOffset + tokenLength,\n\t\t\t\t\tleadingTextStart\n\t\t\t\t)\n\t\t\t);\n\t\t\toffset = startOffset + tokenLength;\n\t\t\treturn true;\n\n\t\tcase 'closer':\n\t\t\t// if we're not nesting then this is easy - close the block\n\t\t\tif ( 1 === stackDepth ) {\n\t\t\t\tcloseOuterElement( startOffset );\n\t\t\t\toffset = startOffset + tokenLength;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// otherwise we're nested and we have to close out the current\n\t\t\t// block and add it as a innerBlock to the parent\n\t\t\tconst stackTop = stack.pop();\n\t\t\tconst text = indoc.substr(\n\t\t\t\tstackTop.prevOffset,\n\t\t\t\tstartOffset - stackTop.prevOffset\n\t\t\t);\n\t\t\tstackTop.children.push( text );\n\t\t\tstackTop.prevOffset = startOffset + tokenLength;\n\t\t\tconst frame = createFrame(\n\t\t\t\tstackTop.element,\n\t\t\t\tstackTop.tokenStart,\n\t\t\t\tstackTop.tokenLength,\n\t\t\t\tstartOffset + tokenLength\n\t\t\t);\n\t\t\tframe.children = stackTop.children;\n\t\t\taddChild( frame );\n\t\t\toffset = startOffset + tokenLength;\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\taddText();\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Grabs the next token match in the string and returns it's details.\n *\n * @private\n *\n * @return {Array}  An array of details for the token matched.\n */\nfunction nextToken() {\n\tconst matches = tokenizer.exec( indoc );\n\t// we have no more tokens\n\tif ( null === matches ) {\n\t\treturn [ 'no-more-tokens' ];\n\t}\n\tconst startedAt = matches.index;\n\tconst [ match, isClosing, name, isSelfClosed ] = matches;\n\tconst length = match.length;\n\tif ( isSelfClosed ) {\n\t\treturn [ 'self-closed', name, startedAt, length ];\n\t}\n\tif ( isClosing ) {\n\t\treturn [ 'closer', name, startedAt, length ];\n\t}\n\treturn [ 'opener', name, startedAt, length ];\n}\n\n/**\n * Pushes text extracted from the indoc string to the output stack given the\n * current rawLength value and offset (if rawLength is provided ) or the\n * indoc.length and offset.\n *\n * @private\n */\nfunction addText() {\n\tconst length = indoc.length - offset;\n\tif ( 0 === length ) {\n\t\treturn;\n\t}\n\toutput.push( indoc.substr( offset, length ) );\n}\n\n/**\n * Pushes a child element to the associated parent element's children for the\n * parent currently active in the stack.\n *\n * @private\n *\n * @param {Frame} frame The Frame containing the child element and it's\n *                      token information.\n */\nfunction addChild( frame ) {\n\tconst { element, tokenStart, tokenLength, prevOffset, children } = frame;\n\tconst parent = stack[ stack.length - 1 ];\n\tconst text = indoc.substr(\n\t\tparent.prevOffset,\n\t\ttokenStart - parent.prevOffset\n\t);\n\n\tif ( text ) {\n\t\tparent.children.push( text );\n\t}\n\n\tparent.children.push( cloneElement( element, null, ...children ) );\n\tparent.prevOffset = prevOffset ? prevOffset : tokenStart + tokenLength;\n}\n\n/**\n * This is called for closing tags. It creates the element currently active in\n * the stack.\n *\n * @private\n *\n * @param {number} endOffset Offset at which the closing tag for the element\n *                           begins in the string. If this is greater than the\n *                           prevOffset attached to the element, then this\n *                           helps capture any remaining nested text nodes in\n *                           the element.\n */\nfunction closeOuterElement( endOffset ) {\n\tconst {\n\t\telement,\n\t\tleadingTextStart,\n\t\tprevOffset,\n\t\ttokenStart,\n\t\tchildren,\n\t} = stack.pop();\n\n\tconst text = endOffset\n\t\t? indoc.substr( prevOffset, endOffset - prevOffset )\n\t\t: indoc.substr( prevOffset );\n\n\tif ( text ) {\n\t\tchildren.push( text );\n\t}\n\n\tif ( null !== leadingTextStart ) {\n\t\toutput.push(\n\t\t\tindoc.substr( leadingTextStart, tokenStart - leadingTextStart )\n\t\t);\n\t}\n\n\toutput.push( cloneElement( element, null, ...children ) );\n}\n\nexport default createInterpolateElement;\n"]}